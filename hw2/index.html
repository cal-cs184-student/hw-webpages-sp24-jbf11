<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    background-color: white;
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
  kbd {
    color: #121212;
  }
</style>
<title>CS 184 Mesh Edit</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

</head>


<body>

<h1 align="middle"><a href="https://cal-cs184-student.github.io/hw-webpages-sp24-jbf11/hw2/index.html">Webpage</a></h1>
<h1 align="middle">CS 284A: Computer Graphics and Imaging, Spring 2024</h1>
<h1 align="middle">Project 2: Mesh Edit</h1>
<h2 align="middle">Dawson Do and Joshua Fernandes</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>
    Overall, this assignment deals with representations and processing of geometric entities. In the first part of this assignment, we implement Bezier curves and surfaces using de Casteljau’s algorithm. We show how Bezier curves are smooth and demonstrate the steps of the algorithm. In the second part of this assignment, we perform mesh operations with the goal of mesh subdivision by the Loop algorithm. We implement methods that require traversal of the half edge mesh data structure, including computation of the vertex normal by area-weighted average of the face normals, flipping an edge in the mesh, and splitting an edge in the mesh. The first method is necessary for smooth Phong shading and the second and third are necessary for the Loop subdivision algorithm. We also develop an understanding of the Loop subdivision algorithm by applying it to several meshes to see how the geometry deforms and how properties of the underlying entities change. For extra credit, we completed the additional task of handling boundaries of triangular meshes, which is necessary for computing vertex normals, splitting edges, and performing Loop subdivision.
</p>
<br>


<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier Curves with 1D de Casteljau Subdivision</h3>


<b>
  Briefly explain de Casteljau's algorithm and how you implemented it in order to evaluate Bezier curves.
</b>
<p>
  We implemented de Casteljau’s algorithm by recursively performing linear interpolations. Our recursive step consists of taking a vector of $n$ input points and performing $n-1$ linear interpolations of adjacent points to return a vector of $n-1$ output points. The input parameter $t$ is taken to be a variable of the class. The recursion consists of repeating this step until we have $1$ output point which is the point on the Bezier curve corresponding to the parameter $t$. Tracing $t$ from 0 to 1 gives the entirety of the curve.

</p>
<br>


<b>
  Take a look at the provided .bzc files and create your own Bezier curve with 6 control points of your choosing. Use this Bezier curve for your screenshots below.
</b>
<p>
    We put six points as shown below to form the basis of the Bezier curve control points. Below, we show the choice of control points.
</p>
<!-- Example of including a single figure -->
<div align="middle">
  <img src="images/bez0.png" align="middle" width="50%">
  <figcaption>Control points used for Bezier curve.</figcaption>
</div>
<br>

<b>
  Show screenshots of each step / level of the evaluation from the original control points down to the final evaluated point. Press <kbd>E</kbd> to step through. Toggle <kbd>C</kbd> to show the completed Bezier curve as well.
</b>
<p>
  Now, we show the evaluations for parameter $t\approx 0.2$. We chose this value since it clearly distinguished each level in a way that minimized overlap. For the final level, the resultant point is colored red and we show the entire curve (generated by the sweep over $t$) in green.
</p>
<!-- Example of including multiple figures -->
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/bez1.png" align="middle" width="400px"/>
        <figcaption>Level 1.</figcaption>
      </td>
      <td>
        <img src="images/bez2.png" align="middle" width="400px"/>
        <figcaption>Level 2.</figcaption>
      </td>
    </tr>
    <br>
    <tr align="center">
      <td>
        <img src="images/bez3.png" align="middle" width="400px"/>
        <figcaption>Level 3.</figcaption>
      </td>
      <td>
        <img src="images/bez4.png" align="middle" width="400px"/>
        <figcaption>Level 4.</figcaption>
      </td>
    </tr>
    <br>
    <tr align="center">
      <td colspan="2">
        <img src="images/bez5.png" align="middle" width="500px"/>
        <figcaption>Level 5 and total curve.</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>


<b>
  Show a screenshot of a slightly different Bezier curve by moving the original control points around and modifying the parameter \(t\) via mouse scrolling.
</b>
<p>
    We then kept the starting and ending points the same, but moved the four entire control points dramatically. We changed to consider $t\approx 0.8$. We see that despite significantly moving the control points, the curve itself does not change dramatically. It is not immediately obvious how moving the control points will change the curve. Also, it is notable that despite considering $t$ close to 1, the resultant point on the curve is closer to the middle. The de Casteljau algorithm does not result in an arc length parameterization of the Bezier curve, which is significant for ensuring smooth implementations.
</p>
<div align="middle">
  <img src="images/bez_shift.png" align="middle" width="50%">
  <figcaption>Bezier curve with control points moved.</figcaption>
</div>
<br>


<h3 align="middle">Part 2: Bezier Surfaces with Separable 1D de Casteljau</h3>
<b>
  Briefly explain how de Casteljau's algorithm extends to Bezier surfaces and how you implemented it in order to evaluate Bezier surfaces.
</b>
<p>
    For a surface, we simply consider two orthogonal directions in which we apply the one-dimensional de Casteljau algorithm in both directions. We take a grid of $n\times m$ control points and take two input parameters, $u$ and $v$. In the first dimension, we apply the de Casteljau algorithm on each of the $m$ sets of $n$ control points using the input parameter $u$. This gives $m$ points that represent the second spatial dimension. Now, we simply apply the one-dimensional de Casteljau algorithm again on these $m$ points using the parameter $v$. Sweeping $u$ and $v$ independently from 0 to 1 gives the entire surface.
</p>
<p>
  We implemented this algorithm by writing the recursive step and recursive loop for the one-dimensional de Casteljau algorithm exactly as in Part 1. The extension to Bezier surfaces only required writing a loop of calls to the one-dimensional algorithm for the first spatial dimension and a final call to the one-dimensional algorithm for the second spatial dimension. Below, we show teapot.bez evaluated by our implementation.
</p>
<br>


<b>
  Show a screenshot of bez/teapot.bez (not .dae) evaluated by your implementation.
</b>
<div align="middle">
  <img src="images/bez_surf.png" align="middle" width="50%">
  <figcaption>Teapot surface computed by Bezier surface.</figcaption>
</div>
<br>


<h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h2>

<h3 align="middle">Part 3: Area-Weighted Vertex Normals</h3>

<b>
  Briefly explain how you implemented the area-weighted vertex normals.
</b>
<p>
    To compute the area-weighted vertex normal, we must average the normal vectors of the neighboring faces of the vertex where we average with respect to the areas of each face. The face objects of the mesh data structure have a built-in normal() method, but they do not have a built-in area() method. Accordingly, we write our own method to compute the face normal vector with magnitude equal to the face area. In this way, we do not need to separately compute the face area and face normal.
</p>
<p>
  First, we write our method specific to triangles, since by assumption our mesh only consists of triangular faces. We utilize the property that the cross product of two vectors gives a vector perpendicular to the two vectors with a magnitude equal to the area of the parallelogram subtended by the vectors. Therefore, the area of the triangle with the two vectors as sides is half the magnitude of this cross product. If we choose a reference vertex for the face, we can compute vectors for two sides by taking the difference of the other two points with the reference. Using the counterclockwise ordering of the half edges on a face, we also ensure that we compute the outward normal by taking the cross product in the correct order. Finally, we recognize that this normal vector is weighted by twice the triangle’s area. Since this will be the case for all faces, we do not need to divide by 2 before averaging the vectors.
Now that we have the face normal vectors weighted by the face area, we now need to use this method to average for each vertex. To do this, we choose any arbitrary half edge from the vertex of interest. Then, we compute the area-weighted normal for this face using the algorithm described above. To reach the next face, we take the twin of the current half edge and then the next half edge from the twin. This gives the next half edge from the vertex clockwise from the starting half edge. Now, we compute the area-weighted normal for this face, and we continue so on until we return to the original half edge we started with. Then, we sum all these area-weighted normals and then normalize the vector.
</p>
<p>
  In this way, we compute the area-weighted normal for each vertex by traversing the mesh carefully. It should be noted that when iterating over faces, we also check if the face is a boundary face (fictitious face) and do not compute the normal for such a face, immediately skipping to the next face, since we only want to consider the contributions from actual faces in the mesh. This allows us to compute vertex normals for meshes that have boundaries.
</p>
<br>


<b>
  Show screenshots of dae/teapot.dae (not .bez) comparing teapot shading with and without vertex normals. Use <kbd>Q</kbd> to toggle default flat shading and Phong shading.
</b>
<p>
    Now, we show the shading of the teapot mesh with and without vertex normals. We see that on the left, without vertex shading, each face is extremely clear and appears flatly oriented. Meanwhile, on the right, with vertex shading, the teapot looks smooth despite being generated from the same underlying mesh. The angularity of the mesh remains visible in the vertex shaded mesh at the boundaries where the object is distinguished against the background, since the geometric domain remains angular. Only the way we compute lighting creates the perception of a smoothly varying normal vector–it is important to note that the true normal vector of the geometry is encoded in the left mesh. Also, in locations where the face normals are varying quickly such as in the spout, vertex shading is not a perfect solution, and we can still see visible gradients in the lighting in these regions. On the whole, this solution gives a much more visually appealing result.
</p>
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/facet_shade.png" align="middle" width="400px"/>
        <figcaption>Teapot by facet shading.</figcaption>
      </td>
      <td>
        <img src="images/phong_shade.png" align="middle" width="400px"/>
        <figcaption>Teapot by Phong shading.</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>


<h3 align="middle">Part 4: Edge Flip</h3>
<b>
  Briefly explain how you implemented the edge flip operation and describe any interesting implementation / debugging tricks you have used.
</b>
<p>
    We implemented the edge flip by saving all the pointers to objects in the submesh that needed to change or were changed in other mesh objects. For edge flip, this consisted of the two faces connecting the flipped edge, the six half edges, and the four vertices. Note that none of the edge objects needed to be changed. Then, we reassigned the necessary pointer fields of each object.
</p>
<br>


<b>
  Show screenshots of the teapot before and after some edge flips.
</b>
<p>
    Below we show the teapot (with Phong shading) after several edge flips. We see some interesting changes to the colors due to inversions of the triangles. Essentially, what we find is that some series of edge flips leads to “dents” in the teapot that then have downward-angled faces which appear darker due to the light source being positioned above the teapot. We also are careful not to flip some edges that would lead to intersecting triangles or degenerate triangles (where all three points are collinear). 
</p>
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/teapot_ref.png" align="middle" width="400px"/>
        <figcaption>Original teapot mesh.</figcaption>
      </td>
      <td>
        <img src="images/teapot_flip.png" align="middle" width="400px"/>
        <figcaption>Teapot mesh with edge flips.</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>


<b>
    Write about your eventful debugging journey, if you have experienced one.
</b>
<p>
   This operation went relatively smoothly, with one exception. When we first wrote the method, we created references to the pointers instead of creating copies. Then, when we began changing the fields, our references were changed and we found undesirable behavior. Once we went to copies instead, we recovered the desired behavior.
</p>
<br>


<h3 align="middle">Part 5: Edge Split</h3>
<b>
  Briefly explain how you implemented the edge split operation and describe any interesting implementation / debugging tricks you have used.
</b>
<p>
    Our strategy for edge splitting was essentially the same as with the edge flip, where we created copies of the pointers to then reassign objects in the mesh. We had the same original set of objects as with edge split. The new aspect of this operation was that we needed to create new objects. In particular, we needed to create three new edges, six new half edges, one new vertex, and two new faces. For these, we needed complete assignment of all pointers.
</p>
<br>


<b>
    Show screenshots of a mesh before and after some edge splits. 
</b>
<p>
    Below, we show the mesh after several edge splits. We repeatedly split the same edge as well as splitting many edges from nearby portions of the mesh. Throughout all splits, we observe that the mesh retains its structure and the shading of the mesh is successfully maintained. We also test to ensure that mesh traversal is working as expected (although this is almost certainly guaranteed simply by correct Phong shading, as the vertex normal calculation requires extensive mesh traversal).
</p>
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/teapot_ref.png" align="middle" width="400px"/>
        <figcaption>Original teapot mesh.</figcaption>
      </td>
      <td>
        <img src="images/teapot_split.png" align="middle" width="400px"/>
        <figcaption>Teapot mesh with edge splits.</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>


<b>
    Show screenshots of a mesh before and after a combination of both edge splits and edge flips.
</b>
<p>
    We continue from the previous mesh where we showed several splits and then flip edges while simultaneously splitting edges. We again see that the connectivity and mesh traversal appears to be maintained. As with just the edge flips case, we see that some of the flips lead to downward-angled faces that register as slightly darker in the lighting calculation. This behavior is expected. From our testing, it appears that the flipping and splitting methods are both working as expected and giving desired results while maintaining connectivity of the mesh elements.
</p>
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/teapot_ref.png" align="middle" width="400px"/>
        <figcaption>Original teapot mesh.</figcaption>
      </td>
      <td>
        <img src="images/teapot_split_flip.png" align="middle" width="400px"/>
        <figcaption>Teapot mesh with both edge flips and splits.</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>


<b>
    Write about your eventful debugging journey, if you have experienced one.
</b>
<p>
    For this portion of the assignment, we found the implementation to work immediately off the bat.
</p>
<br>


<b>
    If you have implemented support for boundary edges, show screenshots of your implementation properly handling split operations on boundary edges.
</b>
<p>
    We also implemented support for boundary edges. The method was essentially the same (and in fact was slightly simpler), as it eliminates the need to create a new edge in the boundary face or separate the boundary face into two. The boundary face simply gains an additional vertex and edge. We wrote the algorithm to create new entities for the boundary and non-boundary case simultaneously, and then simply wrote a conditional to handle if it was not a boundary edge. In this case, we only needed to add a few more elements and update the connectivity appropriately.
</p>
<p>
  Below, we show the VW Beetle mesh (which has boundary edges) and demonstrate the successful implementation of boundary edge splitting. Note that a request to flip a boundary edge is ignored, as there is no logical way to perform such an operation. We split all the edges along the left window (which are boundary edges), some several times. We also split some nearby edges and flip some edges that are near the boundary. We show that our algorithm is robust to this example in its handling of splitting boundary edges.
</p>
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/bdy_ref.png" align="middle" width="400px"/>
        <figcaption>Original VW Beetle mesh showing boundary.</figcaption>
      </td>
      <td>
        <img src="images/bdy_split.png" align="middle" width="400px"/>
        <figcaption>Edge splits at VW Beetle boundary.</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>


<h3 align="middle">Part 6: Loop Subdivision for Mesh Upsampling</h3>
<b>
  Briefly explain how you implemented the loop subdivision and describe any interesting implementation / debugging tricks you have used.
</b>
<p>
    We implemented loop subdivision by the algorithm recommended in the assignment.
First, we iterate through all the vertices and compute the new positions by the Loop subdivision update rule for existing vertices. These positions we store in the “newPosition” field. We compute the position by traversing the neighboring vertices in a similar fashion to how we iterated over neighboring faces in the vertex normal method implemented in Part 3. We also mark all these vertices as not being new with the “isNew” flag, which will be used later.
</p>
<p>
  Second, we compute the new positions for the added vertices (which we have not yet created) by the Loop subdivision update rule. Each added vertex corresponds to an original edge of the mesh, so the new positions are stored in the “newPosition” field within each edge. We iterate over all edges to compute these positions, and traverse the mesh to access the appropriate neighboring vertices.
</p>
<p>
  Third, we split each original edge of the mesh using the method we wrote in Part 5. To do so, we create an iterator at the start of the list of edges, but also create a reference to the final edge of the list (rather than the end of the list). We access this in order 1 time by accessing the end iterator of the list and decrementing, which we can do since the C++ list structure is a doubly-linked list. Thus, we break after we pass the original final edge and avoid an infinite loop of recursively splitting edges. We utilize the fact that any newly created edges are put at the end of the list structure. In this loop, we also mark newly created edges as being “new” if they were not part of an edge that was present in the original mesh. We copy the edge “newPosition” field into the newly created vertex’s “newPosition” field. When we think of the split operation, one of the three new edges is not actually new, but is simply the second half of the original edge. We use the edge field “isNew” within each edge to mark this. We test if this is the case by checking if any of the edges branching from the new vertex reach one of the end points of the original edge. If this is the case the edge is not new, and otherwise, it is new. We also mark the newly created vertex as new with the “isNew” field.
</p>
<p>
  Fourth, we iterate over the new edges. To do so, we use the trick that our current edge iterator is at the end of the original set of edges from splitting. Thus, we continue from that point and avoid uselessly iterating over all the original edges. This saves approximately one-quarter of the iterations, as we add approximately three times the number of edges due to splits. We still must check if the newly added edges are truly new however, since some of the newly created edges were part of original edges as described above. We test this with the edge “isNew” flag. In this loop, we flip any such new edge that connects a new and an old vertex (as marked by the vertex “isNew” flag), such that all new edges will connect two new vertices. 
</p>
<p>
  Fifth and finally, we copy the new positions into the position field of each vertex using the vertex “newPosition” field.
</p>
<br>


<b>
  Take some notes, as well as some screenshots, of your observations on how meshes behave after loop subdivision. What happens to sharp corners and edges? Can you reduce this effect by pre-splitting some edges?
</b>
<p>
    Sharp corners and edges become smoothed out upon Loop subdivision. In the end case, the limit surface will be entirely continuously differentiable, with the possible exception of extraordinary vertices (vertices with degree not equal to six). However, in some cases, we may wish to preserve the angularity of an edge or corner if that is truly the geometry of our system. The rigorous way to do so would be to use different interpolation rules at the sharp boundary to preserve the sharpness. Without doing so, we found that splitting edges orthogonal to a sharp edge of interest prior to upsampling increased the sharpness. This process makes sense as a strategy, since it makes the mesh flat at the two incident interfaces approaching the sharp edge. Thus, when we apply the Loop subdivision rules, it will only locally change the geometry in the elements nearest the boundary. By shrinking the elements near to the boundary of interest, we reduce the length scale over which upsampling smooths the edge, resulting in an apparently sharper boundary.
</p>
<p>
  We demonstrate this below with the cube, following our procedure of symmetrizing the cube as described in the following section. We perform four iterations of Loop subdivision on each mesh. First on the bare cube with the symmetrized mesh, second on the cube with all edges near the boundary of any sharp edge split once, and third with all edges near the boundary of any sharp edge split twice.
</p>
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/cube_sym0.png" align="middle" width="400px"/>
        <figcaption>Mesh with 0 splits and 0 subdivisions.</figcaption>
      </td>
      <td>
        <img src="images/cube_sym2.png" align="middle" width="400px"/>
        <figcaption>Mesh with 0 splits and 4 subdivisions.</figcaption>
      </td>
    </tr>
    <tr align="center">
      <td>
        <img src="images/cube_split_ref.png" align="middle" width="400px"/>
        <figcaption>Mesh with 1 split and 0 subdivisions.</figcaption>
      </td>
      <td>
        <img src="images/cube_split_lim.png" align="middle" width="400px"/>
        <figcaption>Mesh with 1 split and 4 subdivisions.</figcaption>
      </td>
    </tr>
    <br>
    <tr align="center">
      <td>
        <img src="images/cube_doub_ref.png" align="middle" width="400px"/>
        <figcaption>Mesh with 2 splits and 0 subdivisions.</figcaption>
      </td>
      <td>
        <img src="images/cube_doub_lim.png" align="middle" width="400px"/>
        <figcaption>Mesh with 2 splits and 4 subdivisions.</figcaption>
      </td>
    </tr>
  </table>
</div>
<p>
  We can observe that this procedure still leads to a smooth boundary, but it creates a limit surface that has a sharper transition between faces. The transition is increasingly rapid in each mesh that has more edge splits. The obvious drawback is that the splitting method we employ above introduces vertices of degree four and degree eight. The consequence is that vertices of degree less than six bulge outward in the limit surface and vertices of degree greater than six push inward in the limit surface. These consequences follow from the subdivision rules which weight positions by the surrounding neighbors of each vertex. This leads to the limit surface becoming bumpier as we employ our splitting strategy. We could perform some edge flips to improve the degree at these extraordinary vertices to improve the regularity of the mesh and create a better looking limit surface.
</p>
<p>
  We test this by performing some edge flips to have the degree of most vertices be closer to 6. The resultant mesh is shown below (it has the same number of mesh entities as the most refined mesh above that deformed strangely). We see that after doing so, subdivision leads to the desired behavior of sharper edges but clearly a cuboid shape, without the undesired distortion. 
</p>
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/cube_reorg_ref.png" align="middle" width="400px"/>
        <figcaption>Reorganized mesh with 0 subdivisions.</figcaption>
      </td>
      <td>
        <img src="images/cube_reorg_lim.png" align="middle" width="400px"/>
        <figcaption>Reorganized mesh with 4 subdivisions.</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>


<b>
  Load dae/cube.dae. Perform several iterations of loop subdivision on the cube. Notice that the cube becomes slightly asymmetric after repeated subdivisions. Can you pre-process the cube with edge flips and splits so that the cube subdivides symmetrically? Document these effects and explain why they occur. Also explain how your pre-processing helps alleviate the effects.
</b>
<p>
    Below, we show the base cube mesh and the cube after 2 and 4 iterations of Loop subdivision. We see that it does not maintain a symmetrical shape, with some of the original vertices remaining sharp and others smoothing out. This is caused by the fact that the degrees of the cube’s vertices in the triangular mesh are not uniform. One has degree 3, three have degree 4, three have degree 5, and one has degree 6. The lower degree vertices result in sharper corners in the limit surface. In a nutshell, the geometrical object of the cube obeys symmetries that are not respected by the symmetries of the mesh.
</p>
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/cube_asym0.png" align="middle" width="250px"/>
        <figcaption>Original mesh with 0 subdivisions.</figcaption>
      </td>
      <td>
        <img src="images/cube_asym1.png" align="middle" width="250px"/>
        <figcaption>Original mesh with 2 subdivisions.</figcaption>
      </td>
      <td>
        <img src="images/cube_asym2.png" align="middle" width="250px"/>
        <figcaption>Original mesh with 4 subdivisions.</figcaption>
      </td>
    </tr>
  </table>
</div>
<p>
  The strategy we use to solve this problem is to split each diagonal edge on each face of the cube. This leads to a perfectly symmetrical mesh, as shown in the first subfigure below. All vertices are isomorphic to the others and all symmetries of the cube are respected in the symmetries of the mesh. We see that now, this mesh does upsample symmetrically under Loop subdivision. The cube now looks like a rounded cube, rather than a strange oblong object. At the center of each face, we have degree 4 vertices (a total of 6), but this irregularity is inevitable since a cube is topologically equivalent to a sphere.
</p>
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/cube_sym0.png" align="middle" width="250px"/>
        <figcaption>Symmetric mesh with 0 subdivisions.</figcaption>
      </td>
      <td>
        <img src="images/cube_sym1.png" align="middle" width="250px"/>
        <figcaption>Symmetric mesh with 2 subdivisions.</figcaption>
      </td>
      <td>
        <img src="images/cube_sym2.png" align="middle" width="250px"/>
        <figcaption>Symmetric mesh with 4 subdivisions.</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>


<b>
    If you have implemented any extra credit extensions, explain what you did and document how they work with screenshots.
</b>
<p>
    We also implemented handling of meshes with boundaries. This required our split function to process boundary edges correctly, as described and shown in Part 5. The only additional aspect required in this method was the appropriate boundary update rules for Loop subdivision. From this source, we have that the boundary update rules are very simple. For an existing vertex, we use a ⅛-¾-⅛ stencil with the two original mesh neighbors of that vertex, and for a new vertex, we use the midpoint of the two original mesh neighbors. This is the rule we implement, which simply requires checking if the vertex or edge we are computing the new position for lies on the boundary of the mesh. We demonstrate Loop subdivision on a mesh with boundary on the VW Beetle mesh below, with one and two iterations of subdivision. We observe that the mesh gets smoother and smoother and that the boundaries are approximately preserved (they also are smoothed out by the subdivision operation).
</p>
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/beetle0.png" align="middle" width="250px"/>
        <figcaption>VW Beetle mesh with 0 subdivisions.</figcaption>
      </td>
      <td>
        <img src="images/beetle1.png" align="middle" width="250px"/>
        <figcaption>VW Beetle mesh with 1 subdivision.</figcaption>
      </td>
      <td>
        <img src="images/beetle1.png" align="middle" width="250px"/>
        <figcaption>VW Beetle mesh with 2 subdivisions.</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>


</body>
</html>
